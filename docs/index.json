
[{"content":"","date":"15 January 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" All Worbled Up # Challenge description # From the output, we can tell that the input is the flag we need to find, the program takes it in and gives us back some sort of strings, and we need to reverse the process somehow.\nThis challenge only gives us a text file containing Python assembly. At first I tried to convert what the challenge gives back to python code but no luck (or I didn\u0026rsquo;t look hard enough). However, since each function is short enough, I tried to decompile the original code.\nDecompiling the assembly # After finding information here and there on the internet, I learned about Disassembler for Python bytecode, where it documented most of the codes appear in this challenge.\nPython uses its stack for most of the instruction we see, the pattern is:\nPush the function name into the stack. Push the parameters for into the stack. Call the function with its parameters at the top of the stack, pop the function name and its parameters out of the stack. Push the return value into the stack. Let\u0026rsquo;s jump straight into where the output is printed\n42 478 LOAD_GLOBAL 5 (NULL + print)\r490 LOAD_CONST 17 (\u0026#34;Here\u0026#39;s your flag:\u0026#34;)\r492 PUSH_NULL\r494 LOAD_FAST 3 (shmorble)\r496 PUSH_NULL\r498 LOAD_FAST 4 (blorble)\r500 LOAD_FAST 6 (a)\r502 LOAD_FAST 7 (b)\r504 PRECALL 2\r508 CALL 2\r518 PRECALL 1\r522 CALL 1\r532 PRECALL 2\r536 CALL 2 I will visualize how the stack looks like during the run time and hopefully after that we can reconstruct the source code.\n[] [print] # 478 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;] # 490 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble] # 494 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble, blorble] # 498 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble, blorble, a] # 500 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble, blorble, a, b] # 502 # Call blorble with two arguments at the top of the stack with CALL 2 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble, blorble(a, b)] # 508 # Call smorble with one argument at the top of the stack with CALL 1 [print, \u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble(blorble(a, b))] # 522 # Call print with two arguments at the top of the stack with CALL 2 [print(\u0026#34;Here\u0026#39;s your flag:\u0026#34;, smorble(blorble(a, b)))] # 536 That was a good start, we now will see how a and b variables are made\n39 \u0026gt;\u0026gt; 416 PUSH_NULL\r418 LOAD_FAST 2 (worble)\r420 LOAD_FAST 5 (flag)\r422 PRECALL 1\r426 CALL 1\r436 STORE_FAST 6 (a)\r40 438 PUSH_NULL\r440 LOAD_FAST 2 (worble)\r442 LOAD_FAST 5 (flag)\r444 LOAD_CONST 0 (None)\r446 LOAD_CONST 0 (None)\r448 LOAD_CONST 16 (-1)\r450 BUILD_SLICE 3\r452 BINARY_SUBSCR\r462 PRECALL 1\r466 CALL 1\r476 STORE_FAST 7 (b) By doing the same process, we can obtain a = worble(flag). However for b, let\u0026rsquo;s learn about BUILD_SLICE and slice. In other words, slice is a data structure storing information about start, stop, step (optional). And BUILD_SLICE is used to apply the slice to make a set of indices of the data structure like string or list. Back to the challenge, BUILD_SLICE(3) will get 3 values at the top of the stack then make a slice from them (0, 0, -1), and BINARY_SUBSCR will take the slice and the variable at the top of the stack, then apply the slice on that variable. I know I said a lot and you may already know how what is b is already. However, I will also give the visualization for this process.\n[worble] [worble, flag] [worble, flag, None] [worble, flag, None, None] [worble, flag, None, None, -1] # After BUILD_SLICE(3) [worble, flag, [::-1]] # After BINARY_SUBSCR [worble, flag[::-1]] # Call worble with two arguments at the top of the stack with CALL 1 [worble(flag[::-1])] So a = worble(flag) and b = worble(flag[::-1]). Our last job is to reverse worble function to see how the flag is encrypted.\nDisassembly of \u0026lt;code object worble at 0x7fca0cbe0f50, line 6\u0026gt;:\r6 0 RESUME 0\r7 2 LOAD_CONST 1 (5)\r4 STORE_FAST 1 (s1)\r8 6 LOAD_CONST 2 (31)\r8 STORE_FAST 2 (s2) LOAD_CONST pushes the constant into the stack while STORE_FAST takes the loaded constant at the top of the stack, saves it in the variable then pop it out of the stack, that means the code for the first 4 lines is\ns1 = 5 s2 = 31 Next, let\u0026rsquo;s talk about the for loop:\n10 10 LOAD_GLOBAL 1 (NULL + range)\r22 LOAD_GLOBAL 3 (NULL + len)\r34 LOAD_FAST 0 (s)\r36 PRECALL 1\r40 CALL 1\r50 PRECALL 1\r54 CALL 1\r64 GET_ITER\r\u0026gt;\u0026gt; 66 FOR_ITER 40 (to 148)\r68 STORE_FAST 3 (n)\r...\r...\r...\r146 JUMP_BACKWARD 41 (to 66)\r148 LOAD_FAST 2 (s2) I recommend having a look at GET_ITER and FOR_ITER since the documentation did a splendid job explaining how these two instructions work. In short, FOR_ITER is where the for loop will begins, JUMP_BACKWARD will take us back to FOR_ITER for the next iteration and if the iterator is exhausted, FOR_ITER will take us to 148 LOAD_FAST 2 (s2).\nHere is the decompiled code for the for loop:\nfor n in range(len(s)): Next, we have what is inside the for loop:\n11 70 LOAD_FAST 1 (s1)\r72 LOAD_GLOBAL 5 (NULL + ord)\r84 LOAD_FAST 0 (s)\r86 LOAD_FAST 3 (n)\r88 BINARY_SUBSCR\r98 PRECALL 1\r102 CALL 1\r112 BINARY_OP 0 (+)\r116 LOAD_CONST 3 (7)\r118 BINARY_OP 0 (+)\r122 LOAD_CONST 4 (65521)\r124 BINARY_OP 6 (%)\r128 STORE_FAST 1 (s1)\r12 130 LOAD_FAST 1 (s1)\r132 LOAD_FAST 2 (s2)\r134 BINARY_OP 5 (*)\r138 LOAD_CONST 4 (65521)\r140 BINARY_OP 6 (%)\r144 STORE_FAST 2 (s2) Let\u0026rsquo;s meet a new instruction: BINARY_OP. However, its behavior on the stack is not so diffrent than other instructions. According to BINARY_OP:\nBinary operations remove the top two items from the stack (STACK[-1] and STACK[-2]). They perform the operation, then put the result back on the stack.\nWe have all the information we need to decompile what inside the for loop. Once again I will visualize the stack for each stage.\n[] [s1] [s1, ord] [s1, ord, s] [s1, ord, s, n] # After 88 BINARY_SUBSCR [s1, ord, s[n]] # Call ord with one argument at the top of the stack with CALL 1 [s1, ord(s[n])] # BINARY_OP + with two values at the stop of the stack [s1 + ord(s[n])] [s1 + ord(s[n]), 7] # BINARY_OP + with two values at the stop of the stack [s1 + ord(s[n]) + 7] [s1 + ord(s[n]) + 7, 65521] # BINARY_OP % with two values at the stop of the stack [(s1 + ord(s[n]) + 7) % 65521] # Stack pops one value for STORE_FAST, which leads the stack empty [] # s1 = s1 + ord(s[n]) + 7 % 65521 [s1] [s1, s2] # BINARY_OP * with two values at the stop of the stack [s1 * s2, 65521] # BINARY_OP % with two values at the stop of the stack [(s1 * s2) % 65521] # Stack pops one value for STORE_FAST, which leads the stack empty [] # s2 = (s1 * s2) % 65521 The result of the code inside the for loop is:\ns1 = (s1 + ord(s[n]) + 7) % 65521 s2 = (s1 * s2) % 65521 After the for loop:\n14 \u0026gt;\u0026gt; 148 LOAD_FAST 2 (s2)\r150 LOAD_CONST 5 (16)\r152 BINARY_OP 3 (\u0026lt;\u0026lt;)\r156 LOAD_FAST 1 (s1)\r158 BINARY_OP 7 (|)\r162 RETURN_VALUE Again, let\u0026rsquo;s decompile it using the same method:\n[] [s2], [s2, 16], # BINARY_OP % with two values at the stop of the stack [s2 \u0026lt;\u0026lt; 16] [s2 \u0026lt;\u0026lt; 16, 1] # BINARY_OP | with two values at the stop of the stack [(s2 \u0026lt;\u0026lt; 16) | 1] # RETURN_VALUE returns the value at the top of the stack. The result of the code after the for loop is:\nreturn (s2 \u0026lt;\u0026lt; 16) | 1 The complete code for worble is:\ndef worble(s): s1 = 5 s2 = 31 for n in range(len(s)): s1 = (ord(s[n]) + s1 + 7) % 65521 s2 = (s1 * s2) % 65521 r = (s2 \u0026lt;\u0026lt; 16) | s1 return r Result of shmorble and blorble after further reverse engineering:\ndef shmorble(s): # print each character of s r = \u0026#39;\u0026#39; for i in range(len(s)): r += s[i-len(s)] return r def blorble(a, b): # concat a and b in hex format without \u0026#39;0x\u0026#39; return format(a, \u0026#39;x\u0026#39;) + format(b, \u0026#39;x\u0026#39;) Getting flag # To pass the regex check, each character of the flag has to be one in \u0026ldquo;bdrw013\u0026rdquo;, my solution is just bruteforcing these 9 characters.\nFull script # def worble(s): s1 = 5 s2 = 31 for n in range(len(s)): s1 = (ord(s[n]) + s1 + 7) % 65521 s2 = (s1 * s2) % 65521 r = (s2 \u0026lt;\u0026lt; 16) | s1 return r def shmorble(s): r = \u0026#39;\u0026#39; for i in range(len(s)): r += s[i-len(s)] return r def blorble(a, b): return format(a, \u0026#39;x\u0026#39;) + format(b, \u0026#39;x\u0026#39;) for _0 in \u0026#34;bdrw013\u0026#34;: for _1 in \u0026#34;bdrw013\u0026#34;: for _2 in \u0026#34;bdrw013\u0026#34;: for _3 in \u0026#34;bdrw013\u0026#34;: for _4 in \u0026#34;bdrw013\u0026#34;: for _5 in \u0026#34;bdrw013\u0026#34;: for _6 in \u0026#34;bdrw013\u0026#34;: for _7 in \u0026#34;bdrw013\u0026#34;: for _8 in \u0026#34;bdrw013\u0026#34;: flag = f\u0026#34;uoftctf{{{\u0026#39;\u0026#39;.join([_0, _1, _2, _3, _4, _5, _6, _7, _8])}}}\u0026#34; if worble(flag) == 0xa81c0750 and worble(flag[::-1]) == 0xd48f0750: print(flag) exit(0) Flag # uoftctf{d3w0rb13d} ","date":"15 January 2024","externalUrl":null,"permalink":"/posts/uoftctf2024/","section":"Posts","summary":"","title":"[UofT CTF 2024] All Worbled Up Write-up","type":"posts"},{"content":"","date":"15 January 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"15 January 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"15 January 2024","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"","date":"15 January 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]